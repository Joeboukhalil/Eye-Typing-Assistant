<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mobile Eye Typing</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html, body { margin:0; padding:0; overflow:hidden; height:100%; width:100%; }
#video, #canvas { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
#dot { position:absolute; width:20px; height:20px; background:red; border-radius:50%; pointer-events:none; z-index:2; }
#keyboard { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); display:flex; flex-wrap:wrap; width:90%; justify-content:center; z-index:3; }
.key { width:15%; height:50px; margin:2px; background:#ccc; display:flex; align-items:center; justify-content:center; border-radius:5px; user-select:none; cursor:pointer; font-size:16px; text-align:center; }
#output { position:absolute; top:5%; left:50%; transform:translateX(-50%); font-size:24px; background:rgba(255,255,255,0.7); padding:8px; border-radius:5px; z-index:4; }
.key.active { background:orange; }
</style>
</head>
<body>

<video id="video" autoplay muted playsinline></video>
<canvas id="canvas"></canvas>
<div id="dot"></div>
<div id="output"></div>
<div id="keyboard"></div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const dot = document.getElementById('dot');
const keyboardDiv = document.getElementById('keyboard');
const output = document.getElementById('output');

let text = "";
const keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
keys.push('SPACE','DEL','SPEAK');

keys.forEach(k=>{
  const keyEl = document.createElement('div');
  keyEl.className='key';
  keyEl.innerText=k;
  keyEl.onclick=()=>handleKey(k);
  keyboardDiv.appendChild(keyEl);
});

function handleKey(k){
  if(k==='DEL') text=text.slice(0,-1);
  else if(k==='SPACE') text+=' ';
  else if(k==='SPEAK'){ 
    const utter = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(utter);
  } else text+=k;
  output.innerText=text;
}

// Camera setup for mobile
navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}})
.then(stream=>{video.srcObject=stream;})
.catch(err=>{alert("Camera access denied"); console.error(err);});

let blinkTime = null;
let eyesClosed = false;
let cycling = false;
let currentIndex = 0;
let cycleInterval = null;

async function run(){
  const model = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh);

  async function detect(){
    if(video.readyState < 2){ requestAnimationFrame(detect); return; }
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    const predictions = await model.estimateFaces({input:video, returnTensors:false, flipHorizontal:true});
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(predictions.length>0){
      const keypoints = predictions[0].scaledMesh;

      // Use normalized landmarks for distance tolerance
      const leftEye = keypoints.slice(33,133);
      const rightEye = keypoints.slice(362,462);

      function avgPoint(pts){return pts.reduce((a,b)=>({x:a.x+b.x, y:a.y+b.y}), {x:0,y:0});}
      let leftAvg = avgPoint(leftEye); leftAvg.x/=leftEye.length; leftAvg.y/=leftEye.length;
      let rightAvg = avgPoint(rightEye); rightAvg.x/=rightEye.length; rightAvg.y/=rightEye.length;

      const dotX = ((leftAvg.x + rightAvg.x)/2) * window.innerWidth;
      const dotY = ((leftAvg.y + rightAvg.y)/2) * window.innerHeight;
      dot.style.left=`${dotX-10}px`;
      dot.style.top=`${dotY-10}px`;

      // Blink detection using relative distance
      const leftDist = Math.hypot(leftEye[0].x-leftEye[8].x,leftEye[0].y-leftEye[8].y);
      const rightDist = Math.hypot(rightEye[0].x-rightEye[8].x,rightEye[0].y-rightEye[8].y);
      const blinkThreshold = 0.03; // normalized scale, works at any distance

      if(leftDist < blinkThreshold && rightDist < blinkThreshold){
        if(!eyesClosed){
          eyesClosed = true;
          blinkTime = Date.now();
        } else if(Date.now() - blinkTime > 2000){
          // Long blink = confirm letter if cycling
          if(cycling){
            handleKey(keys[currentIndex]);
            stopCycling();
          }
        }
      } else {
        if(eyesClosed && Date.now()-blinkTime < 2000){
          // Short blink = toggle cycling
          if(!cycling) startCycling();
          else stopCycling();
        }
        eyesClosed = false;
      }
    }
    requestAnimationFrame(detect);
  }
  detect();
}

function startCycling(){
  cycling = true;
  currentIndex = 0;
  updateActiveKey();
  cycleInterval = setInterval(()=>{
    currentIndex = (currentIndex + 1) % keys.length;
    updateActiveKey();
  }, 3000);
}

function stopCycling(){
  cycling = false;
  clearInterval(cycleInterval);
  updateActiveKey();
}

function updateActiveKey(){
  document.querySelectorAll('.key').forEach((el,i)=>{
    if(i===currentIndex && cycling) el.classList.add('active');
    else el.classList.remove('active');
  });
}

// Mobile touch fallback (tap to cycle)
canvas.addEventListener('touchstart',()=>{
  if(!cycling) startCycling();
  else stopCycling();
});

video.onloadeddata = run;
</script>
</body>
</html>